<?php

namespace app\libraries;
use app\exceptions\IOException;

/**
 * Class Utils
 */
class Utils {
    /**
     * Strips some string recursively from an array, removing it from both the
     * array's keys and its values
     *
     * @param string $string
     * @param array  $array
     */
    public static function stripStringFromArray($string, &$array) {
        foreach($array as $key => $value) {
            if (is_array($value)) {
                Utils::stripStringFromArray($string, $value);
            }
            else {
                $value = str_replace($string, "", $value);
            }
            $new_key = str_replace($string, "", $key);
            if($new_key != $key) {
                $array[$new_key] = $value;
                unset($array[$key]);
            } else {
                $array[$key] = $value;
            }

        }
    }

    /**
     * Defines a new default str_pad that's useful for things like parts of a datetime
     *
     * @param        $string
     * @param int    $pad_width  [optional]
     * @param string $pad_string [optional]
     * @param int    $pad_type   [optional]
     *
     * @return string
     */
    public static function pad($string, $pad_width = 2, $pad_string = '0', $pad_type = STR_PAD_LEFT) {
        return str_pad($string, $pad_width, $pad_string, $pad_type);
    }

    /**
     * Removes the trailing comma at the end of any JSON block. This means that if you had:
     * [ "element": { "a", "b", }, ]
     * this function would return:
     * [ "element": { "a", "b" } ]
     *
     * We do this as we have the potential of trailing commas in the JSON files that are generated by
     * the submission server
     *
     * @param string $json
     *
     * @return string
     */
    public static function removeTrailingCommas($json) {
        $json = preg_replace('/,\s*([\]}])/m', '$1', $json);

        return $json;
    }

    /**
     * Generates a pseudo-random string that should be cryptographically secure for use
     * as tokens and other things where uniqueness is of absolute importance. The generated
     * string is twice as long as the given number of bytes as the parameter.
     *
     * @param int $bytes
     *
     * @return string
     */
    public static function generateRandomString($bytes = 16) {
        return bin2hex(openssl_random_pseudo_bytes($bytes));
    }
    
    /**
     * Given a string, convert all newline characters to "<br />" while also
     * performing htmlentities on all elements that are not for the new lines
     * @param string $string
     * @return string
     */
    public static function prepareHtmlMessage($string) {
        $string = str_replace("<br>", "<br />", nl2br($string));
        $string = explode("<br />", $string);
        return implode("<br />", array_map("htmlentities", $string));
    }
}
